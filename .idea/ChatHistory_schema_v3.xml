<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="chatSessions" value="{&quot;2cce3d3d-618b-4fe9-a046-0774c56db24b&quot;:{&quot;id&quot;:&quot;2cce3d3d-618b-4fe9-a046-0774c56db24b&quot;,&quot;name&quot;:&quot;Resolving \u0027No value passed for parameter documentPath\u0027 in SpaceViewModel&quot;,&quot;timestamp&quot;:1763586217803,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:composeApp/src/commonMain/kotlin/viewmodels/SpaceViewModel.kt, lines\u003dALL(1-615)\n/*package viewmodels\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport auth.User\nimport auth.upload\nimport data.PostItemData\nimport data.Story\nimport dev.gitlive.firebase.auth.FirebaseAuth\nimport dev.gitlive.firebase.firestore.FieldValue\nimport dev.gitlive.firebase.firestore.FirebaseFirestore\nimport dev.gitlive.firebase.firestore.Timestamp\n// CORRECTED: Removed invalid imports for whereGreaterThanOrEqualTo and whereLessThanOrEqualTo\nimport dev.gitlive.firebase.storage.FirebaseStorage\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\n\ndata class SpaceUiState(\n    val userName: String \u003d \&quot;\&quot;,\n    val userAvatarUrl: String? \u003d null,\n    val stories: List\u003cStory\u003e \u003d emptyList(),\n    val posts: List\u003cPostItemData\u003e \u003d emptyList(),\n    val isLoading: Boolean \u003d false,\n    val error: String? \u003d null\n)\n\nopen class SpaceViewModel(\n    private val firestore: FirebaseFirestore,\n    private val storage: FirebaseStorage,\n    private val auth: FirebaseAuth\n) : ViewModel() {\n\n    private val _uiState \u003d MutableStateFlow(SpaceUiState(isLoading \u003d true))\n    val uiState: StateFlow\u003cSpaceUiState\u003e \u003d _uiState.asStateFlow()\n\n    private val _searchResults \u003d MutableStateFlow\u003cList\u003cUser\u003e\u003e(emptyList())\n    val searchResults: StateFlow\u003cList\u003cUser\u003e\u003e \u003d _searchResults.asStateFlow()\n\n    private val _stories \u003d MutableStateFlow\u003cList\u003cStory\u003e\u003e(emptyList())\n    val stories: StateFlow\u003cList\u003cStory\u003e\u003e \u003d _stories.asStateFlow()\n\n    private val _feeds \u003d MutableStateFlow\u003cList\u003cStory\u003e\u003e(emptyList())\n    val feeds: StateFlow\u003cList\u003cStory\u003e\u003e \u003d _feeds.asStateFlow()\n\n    init {\n        loadInitialData()\n        listenForFeeds()\n    }\n\n    private fun loadInitialData() {\n        viewModelScope.launch {\n            _uiState.value \u003d _uiState.value.copy(isLoading \u003d true, error \u003d null)\n            try {\n                val firebaseUser \u003d auth.currentUser\n                val userName \u003d firebaseUser?.displayName ?: \&quot;User\&quot;\n                val userAvatarUrl \u003d firebaseUser?.photoURL\n\n                val postsSnapshot \u003d firestore.collection(\&quot;posts\&quot;).get()\n                val posts \u003d postsSnapshot.documents.map { it.data\u003cPostItemData\u003e() }\n\n                _uiState.value \u003d SpaceUiState(\n                    userName \u003d userName,\n                    userAvatarUrl \u003d userAvatarUrl,\n                    stories \u003d emptyList(),\n                    posts \u003d posts,\n                    isLoading \u003d false\n                )\n            } catch (e: Exception) {\n                println(\&quot;Error loading data: ${e.message}\&quot;)\n                _uiState.value \u003d _uiState.value.copy(\n                    isLoading \u003d false,\n                    error \u003d \&quot;Failed to load data: ${e.message}\&quot;\n                )\n            }\n        }\n    }\n\n    private fun listenForFeeds() {\n        viewModelScope.launch {\n            try {\n                firestore.collection(\&quot;feeds\&quot;).snapshots.collect { snapshot -\u003e\n                    println(\&quot;Received snapshot for feeds: ${snapshot.documents.size} documents\&quot;)\n                    val fetchedFeed \u003d snapshot.documents.map { doc -\u003e doc.data\u003cStory\u003e() }\n                    _feeds.value \u003d fetchedFeed\n                }\n            } catch (e: Exception) {\n                println(\&quot;Error listening for feeds: ${e.message}\&quot;)\n                _feeds.value \u003d emptyList()\n            }\n        }\n    }\n\n    fun searchUsers(query: String) {\n        viewModelScope.launch {\n            if (query.length \u003c 2) {\n                _searchResults.value \u003d emptyList()\n                return@launch\n            }\n            try {\n                val querySnapshot \u003d firestore.collection(\&quot;users\&quot;)\n                    .where {\n                        \&quot;displayName\&quot; greaterThanOrEqualTo query\n                        \&quot;displayName\&quot; lessThanOrEqualTo query + \u0027\\uf8ff\u0027\n                    }\n                    .limit(10)\n                    .get()\n                val users \u003d querySnapshot.documents.map { it.data\u003cUser\u003e() }\n                _searchResults.value \u003d users\n            } catch (e: Exception) {\n                println(\&quot;Error searching users: ${e.message}\&quot;)\n                _searchResults.value \u003d emptyList()\n            }\n        }\n    }\n\n\n    fun addStory(\n        mediaContent: ByteArray?,\n        thumbnailContent: ByteArray?,\n        textContent: String?,\n        contentType: Story.ContentType,\n        isFeed: Boolean,\n        aspectRatio: Float,\n        onProgress: (String) -\u003e Unit,\n        onSuccess: () -\u003e Unit,\n        onError: (String) -\u003e Unit\n    ) {\n        viewModelScope.launch {\n            val currentUser \u003d auth.currentUser\n            if (currentUser \u003d\u003d null) {\n                onError(\&quot;User not authenticated.\&quot;)\n                return@launch\n            }\n\n            onProgress(\&quot;Preparing content...\&quot;)\n            val storyId \u003d \&quot;story_${currentUser.uid}_${Timestamp.now().seconds}\&quot;\n            var finalContentUrl: String? \u003d null\n            var finalThumbnailUrl: String? \u003d null\n\n            try {\n                if (mediaContent !\u003d null) {\n                    val mediaFileName \u003d \&quot;${contentType.name.lowercase()}_${Timestamp.now().nanoseconds}\&quot;\n                    val mediaStoragePath \u003d \&quot;stories/${currentUser.uid}/$storyId/$mediaFileName\&quot;\n                    onProgress(\&quot;Uploading ${contentType.name.lowercase()}...\&quot;)\n                    finalContentUrl \u003d uploadFileToStorage(mediaContent, mediaStoragePath)\n                }\n\n                if (thumbnailContent !\u003d null) {\n                    onProgress(\&quot;Uploading thumbnail...\&quot;)\n                    val thumbnailFileName \u003d \&quot;thumbnail_${Timestamp.now().nanoseconds}\&quot;\n                    val thumbnailStoragePath \u003d \&quot;stories/${currentUser.uid}/$storyId/thumbnails/$thumbnailFileName\&quot;\n                    finalThumbnailUrl \u003d uploadFileToStorage(thumbnailContent, thumbnailStoragePath)\n                }\n\n                onProgress(\&quot;Saving details...\&quot;)\n                val newStory \u003d Story(\n                    storyId \u003d storyId,\n                    userId \u003d currentUser.uid,\n                    userName \u003d currentUser.displayName ?: \&quot;Anonymous\&quot;,\n                    userProfileUrl \u003d currentUser.photoURL,\n                    contentType \u003d contentType,\n                    contentUrl \u003d finalContentUrl,\n                    thumbnailUrl \u003d finalThumbnailUrl,\n                    textContent \u003d if (contentType \u003d\u003d Story.ContentType.TEXT) textContent else null,\n                    // CORRECTED: \u0027timestamp\u0027 is removed. It will be handled by the data class.\n                    duration \u003d 0,\n                    aspectRatio \u003d aspectRatio,\n                    isFeed \u003d isFeed,\n                    expiryTimestamp \u003d null,\n                    isViewed \u003d false,\n                    viewCount \u003d 0,\n                    interactiveElements \u003d emptyList(),\n                    locationTag \u003d null,\n                    musicTrack \u003d null,\n                    privacySetting \u003d Story.PrivacySetting.PUBLIC,\n                    isArchived \u003d false,\n                    callToAction \u003d null,\n                    linkUrl \u003d null,\n                    isBusinessStory \u003d false,\n                    likeCount \u003d 0,\n                    likedByUserIds \u003d emptyList(),\n                    commentCount \u003d 0,\n                    comments \u003d emptyList(),\n                    shareCount \u003d 0,\n                    sharedByUserIds \u003d emptyList(),\n                    isLiked \u003d false\n                )\n\n                val collectionName \u003d if (isFeed) \&quot;feeds\&quot; else \&quot;stories\&quot;\n                firestore.collection(collectionName).document(storyId).set(newStory)\n\n                onProgress(\&quot;${if (isFeed) \&quot;Feed\&quot; else \&quot;Story\&quot;} posted successfully!\&quot;)\n                onSuccess()\n\n            } catch (e: Exception) {\n                println(\&quot;Error adding story: ${e.message}\&quot;)\n                onError(e.message ?: \&quot;An unknown error occurred while adding the story.\&quot;)\n            }\n        }\n    }\n\n    private suspend fun uploadFileToStorage(\n        fileBytes: ByteArray,\n        storagePath: String\n    ): String {\n        val storageRef \u003d storage.reference(storagePath)\n        // CORRECTED: The function is \u0027putBytes\u0027, not \u0027upload\u0027\n        storageRef.upload(fileBytes)\n        return storageRef.getDownloadUrl()\n    }\n}*/\npackage viewmodels\n\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport auth.User\nimport auth.upload\nimport data.PostItemData\nimport data.Space // NEW: Import for Space data model\nimport data.SpaceMessage // NEW: Import for SpaceMessage data model\nimport data.Story\nimport dev.gitlive.firebase.auth.FirebaseAuth\nimport dev.gitlive.firebase.firestore.FieldValue\nimport dev.gitlive.firebase.firestore.FirebaseFirestore\nimport dev.gitlive.firebase.firestore.Timestamp\nimport dev.gitlive.firebase.firestore.where // NEW: Import for Firestore queries\nimport dev.gitlive.firebase.storage.FirebaseStorage\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\n\n// --- Original UI State (for Home/Feeds) ---\ndata class SpaceUiState(\n    val userName: String \u003d \&quot;\&quot;,\n    val userAvatarUrl: String? \u003d null,\n    val stories: List\u003cStory\u003e \u003d emptyList(),\n    val posts: List\u003cPostItemData\u003e \u003d emptyList(),\n    val isLoading: Boolean \u003d false,\n    val error: String? \u003d null\n)\n\n// --- View Model with integrated \&quot;Spaces\&quot; logic ---\nopen class SpaceViewModel(\n    private val firestore: FirebaseFirestore,\n    private val storage: FirebaseStorage,\n    private val auth: FirebaseAuth\n) : ViewModel() {\n\n    // --- Original State Properties ---\n    private val _uiState \u003d MutableStateFlow(SpaceUiState(isLoading \u003d true))\n    val uiState: StateFlow\u003cSpaceUiState\u003e \u003d _uiState.asStateFlow()\n\n    private val _searchResults \u003d MutableStateFlow\u003cList\u003cUser\u003e\u003e(emptyList())\n    val searchResults: StateFlow\u003cList\u003cUser\u003e\u003e \u003d _searchResults.asStateFlow()\n\n    private val _stories \u003d MutableStateFlow\u003cList\u003cStory\u003e\u003e(emptyList())\n    val stories: StateFlow\u003cList\u003cStory\u003e\u003e \u003d _stories.asStateFlow()\n\n    private val _feeds \u003d MutableStateFlow\u003cList\u003cStory\u003e\u003e(emptyList())\n    val feeds: StateFlow\u003cList\u003cStory\u003e\u003e \u003d _feeds.asStateFlow()\n\n    // --- NEW: State Properties for the \&quot;Spaces\&quot; Feature ---\n\n    // For listing all spaces\n    private val _spaces \u003d MutableStateFlow\u003cList\u003cSpace\u003e\u003e(emptyList())\n    val spaces: StateFlow\u003cList\u003cSpace\u003e\u003e \u003d _spaces.asStateFlow()\n    private val _isLoadingSpaces \u003d MutableStateFlow(true)\n    val isLoadingSpaces: StateFlow\u003cBoolean\u003e \u003d _isLoadingSpaces.asStateFlow()\n\n    // For creating a new space\n    val spaceName \u003d mutableStateOf(\&quot;\&quot;)\n    val spaceDescription \u003d mutableStateOf(\&quot;\&quot;)\n    private val _isCreatingSpace \u003d MutableStateFlow(false)\n    val isCreatingSpace: StateFlow\u003cBoolean\u003e \u003d _isCreatingSpace.asStateFlow()\n\n    // For viewing a single space\u0027s details, posts, and chat\n    private val _currentSpace \u003d MutableStateFlow\u003cSpace?\u003e(null)\n    val currentSpace: StateFlow\u003cSpace?\u003e \u003d _currentSpace.asStateFlow()\n\n    private val _spacePosts \u003d MutableStateFlow\u003cList\u003cStory\u003e\u003e(emptyList())\n    val spacePosts: StateFlow\u003cList\u003cStory\u003e\u003e \u003d _spacePosts.asStateFlow()\n\n    private val _spaceMessages \u003d MutableStateFlow\u003cList\u003cSpaceMessage\u003e\u003e(emptyList())\n    val spaceMessages: StateFlow\u003cList\u003cSpaceMessage\u003e\u003e \u003d _spaceMessages.asStateFlow()\n    val newMessageText \u003d mutableStateOf(\&quot;\&quot;)\n\n\n    init {\n        // Original data loading\n        loadInitialData()\n        listenForFeeds()\n        // NEW: Load spaces when ViewModel is created\n        fetchSpaces()\n    }\n\n    // --- Original Methods (Unchanged) ---\n\n    private fun loadInitialData() {\n        viewModelScope.launch {\n            _uiState.value \u003d _uiState.value.copy(isLoading \u003d true, error \u003d null)\n            try {\n                val firebaseUser \u003d auth.currentUser\n                val userName \u003d firebaseUser?.displayName ?: \&quot;User\&quot;\n                val userAvatarUrl \u003d firebaseUser?.photoURL\n\n                val postsSnapshot \u003d firestore.collection(\&quot;posts\&quot;).get()\n                val posts \u003d postsSnapshot.documents.map { it.data\u003cPostItemData\u003e() }\n\n                _uiState.value \u003d SpaceUiState(\n                    userName \u003d userName,\n                    userAvatarUrl \u003d userAvatarUrl,\n                    stories \u003d emptyList(),\n                    posts \u003d posts,\n                    isLoading \u003d false\n                )\n            } catch (e: Exception) {\n                println(\&quot;Error loading data: ${e.message}\&quot;)\n                _uiState.value \u003d _uiState.value.copy(\n                    isLoading \u003d false,\n                    error \u003d \&quot;Failed to load data: ${e.message}\&quot;\n                )\n            }\n        }\n    }\n\n    private fun listenForFeeds() {\n        viewModelScope.launch {\n            try {\n                firestore.collection(\&quot;feeds\&quot;).snapshots.collect { snapshot -\u003e\n                    println(\&quot;Received snapshot for feeds: ${snapshot.documents.size} documents\&quot;)\n                    val fetchedFeed \u003d snapshot.documents.map { doc -\u003e doc.data\u003cStory\u003e() }\n                    _feeds.value \u003d fetchedFeed\n                }\n            } catch (e: Exception) {\n                println(\&quot;Error listening for feeds: ${e.message}\&quot;)\n                _feeds.value \u003d emptyList()\n            }\n        }\n    }\n\n    fun searchUsers(query: String) {\n        viewModelScope.launch {\n            if (query.length \u003c 2) {\n                _searchResults.value \u003d emptyList()\n                return@launch\n            }\n            try {\n                val querySnapshot \u003d firestore.collection(\&quot;users\&quot;)\n                    .where {\n                        \&quot;displayName\&quot; greaterThanOrEqualTo query\n                        \&quot;displayName\&quot; lessThanOrEqualTo query + \u0027\\uf8ff\u0027\n                    }\n                    .limit(10)\n                    .get()\n                val users \u003d querySnapshot.documents.map { it.data\u003cUser\u003e() }\n                _searchResults.value \u003d users\n            } catch (e: Exception) {\n                println(\&quot;Error searching users: ${e.message}\&quot;)\n                _searchResults.value \u003d emptyList()\n            }\n        }\n    }\n\n\n    fun addStory(\n        mediaContent: ByteArray?,\n        thumbnailContent: ByteArray?,\n        textContent: String?,\n        contentType: Story.ContentType,\n        isFeed: Boolean,\n        aspectRatio: Float,\n        onProgress: (String) -\u003e Unit,\n        onSuccess: () -\u003e Unit,\n        onError: (String) -\u003e Unit\n    ) {\n        viewModelScope.launch {\n            val currentUser \u003d auth.currentUser\n            if (currentUser \u003d\u003d null) {\n                onError(\&quot;User not authenticated.\&quot;)\n                return@launch\n            }\n\n            onProgress(\&quot;Preparing content...\&quot;)\n            val storyId \u003d \&quot;story_${currentUser.uid}_${Timestamp.now().seconds}\&quot;\n            var finalContentUrl: String? \u003d null\n            var finalThumbnailUrl: String? \u003d null\n\n            try {\n                if (mediaContent !\u003d null) {\n                    val mediaFileName \u003d \&quot;${contentType.name.lowercase()}_${Timestamp.now().nanoseconds}\&quot;\n                    val mediaStoragePath \u003d \&quot;stories/${currentUser.uid}/$storyId/$mediaFileName\&quot;\n                    onProgress(\&quot;Uploading ${contentType.name.lowercase()}...\&quot;)\n                    finalContentUrl \u003d uploadFileToStorage(mediaContent, mediaStoragePath)\n                }\n\n                if (thumbnailContent !\u003d null) {\n                    onProgress(\&quot;Uploading thumbnail...\&quot;)\n                    val thumbnailFileName \u003d \&quot;thumbnail_${Timestamp.now().nanoseconds}\&quot;\n                    val thumbnailStoragePath \u003d \&quot;stories/${currentUser.uid}/$storyId/thumbnails/$thumbnailFileName\&quot;\n                    finalThumbnailUrl \u003d uploadFileToStorage(thumbnailContent, thumbnailStoragePath)\n                }\n\n                onProgress(\&quot;Saving details...\&quot;)\n                val newStory \u003d Story(\n                    storyId \u003d storyId,\n                    userId \u003d currentUser.uid,\n                    userName \u003d currentUser.displayName ?: \&quot;Anonymous\&quot;,\n                    userProfileUrl \u003d currentUser.photoURL,\n                    contentType \u003d contentType,\n                    contentUrl \u003d finalContentUrl,\n                    thumbnailUrl \u003d finalThumbnailUrl,\n                    textContent \u003d if (contentType \u003d\u003d Story.ContentType.TEXT) textContent else null,\n                    duration \u003d 0,\n                    aspectRatio \u003d aspectRatio,\n                    isFeed \u003d isFeed,\n                    expiryTimestamp \u003d null,\n                    isViewed \u003d false,\n                    viewCount \u003d 0,\n                    interactiveElements \u003d emptyList(),\n                    locationTag \u003d null,\n                    musicTrack \u003d null,\n                    privacySetting \u003d Story.PrivacySetting.PUBLIC,\n                    isArchived \u003d false,\n                    callToAction \u003d null,\n                    linkUrl \u003d null,\n                    isBusinessStory \u003d false,\n                    likeCount \u003d 0,\n                    likedByUserIds \u003d emptyList(),\n                    commentCount \u003d 0,\n                    comments \u003d emptyList(),\n                    shareCount \u003d 0,\n                    sharedByUserIds \u003d emptyList(),\n                    isLiked \u003d false\n                )\n\n                val collectionName \u003d if (isFeed) \&quot;feeds\&quot; else \&quot;stories\&quot;\n                firestore.collection(collectionName).document(storyId).set(newStory)\n\n                onProgress(\&quot;${if (isFeed) \&quot;Feed\&quot; else \&quot;Story\&quot;} posted successfully!\&quot;)\n                onSuccess()\n\n            } catch (e: Exception) {\n                println(\&quot;Error adding story: ${e.message}\&quot;)\n                onError(e.message ?: \&quot;An unknown error occurred while adding the story.\&quot;)\n            }\n        }\n    }\n\n    private suspend fun uploadFileToStorage(\n        fileBytes: ByteArray,\n        storagePath: String\n    ): String {\n        val storageRef \u003d storage.reference(storagePath)\n        storageRef.upload(fileBytes)\n        return storageRef.getDownloadUrl()\n    }\n\n\n    // --- NEW: Methods for the \&quot;Spaces\&quot; Feature ---\n\n    /**\n     * Fetches all spaces from Firestore in real-time.\n     */\n    fun fetchSpaces() {\n        viewModelScope.launch {\n            _isLoadingSpaces.value \u003d true\n            try {\n                firestore.collection(\&quot;spaces\&quot;).snapshots.collect { snapshot -\u003e\n                    _spaces.value \u003d snapshot.documents.map { it.data() }\n                    _isLoadingSpaces.value \u003d false\n                }\n            } catch (e: Exception) {\n                println(\&quot;Error fetching spaces: ${e.message}\&quot;)\n                _isLoadingSpaces.value \u003d false\n            }\n        }\n    }\n\n    /**\n     * Creates a new space, uploads a cover image, and adds the current user as the owner.\n     * @param coverImage The cover image as a ByteArray.\n     * @param onResult Callback providing success status and the new space\u0027s ID.\n     */\n    fun createSpace(coverImage: ByteArray?, onResult: (success: Boolean, spaceId: String?) -\u003e Unit) {\n        viewModelScope.launch {\n            _isCreatingSpace.value \u003d true\n            val currentUser \u003d auth.currentUser ?: run {\n                onResult(false, null)\n                _isCreatingSpace.value \u003d false\n                return@launch\n            }\n            // CORRECTED: document() with no arguments creates a new document reference with a unique ID.\n            val spaceId \u003d firestore.collection(\&quot;spaces\&quot;).document().id\n\n            try {\n                val coverImageUrl \u003d if (coverImage !\u003d null) {\n                    uploadFileToStorage(coverImage, \&quot;space_covers/$spaceId.jpg\&quot;)\n                } else \&quot;\&quot;\n\n                val newSpace \u003d Space(\n                    id \u003d spaceId,\n                    name \u003d spaceName.value.trim(),\n                    description \u003d spaceDescription.value.trim(),\n                    ownerId \u003d currentUser.uid,\n                    memberIds \u003d listOf(currentUser.uid),\n                    coverImageUrl \u003d coverImageUrl\n                )\n                firestore.collection(\&quot;spaces\&quot;).document(spaceId).set(newSpace)\n\n                // Reset state and report success\n                spaceName.value \u003d \&quot;\&quot;\n                spaceDescription.value \u003d \&quot;\&quot;\n                _isCreatingSpace.value \u003d false\n                onResult(true, spaceId)\n            } catch (e: Exception) {\n                println(\&quot;Error creating space: ${e.message}\&quot;)\n                _isCreatingSpace.value \u003d false\n                onResult(false, null)\n            }\n        }\n    }\n\n    /**\n     * Joins the current user to a space by adding their UID to the memberIds array.\n     */\n    fun joinSpace(spaceId: String) {\n        viewModelScope.launch {\n            val currentUser \u003d auth.currentUser ?: return@launch\n            try {\n                // CORRECTED: The update function requires field-value pairs using the `to` infix function.\n                firestore.collection(\&quot;spaces\&quot;).document(spaceId).update(\n                    \&quot;memberIds\&quot; to FieldValue.arrayUnion(currentUser.uid)\n                )\n            } catch (e: Exception) {\n                println(\&quot;Error joining space: ${e.message}\&quot;)\n            }\n        }\n    }\n\n    /**\n     * Loads the details for a specific space and listens for its associated posts and chat messages.\n     * Establishes real-time listeners.\n     */\n    fun loadSpaceDetails(spaceId: String) {\n        viewModelScope.launch {\n            // Listen for space details\n            firestore.collection(\&quot;spaces\&quot;).document(spaceId).snapshots.collect { snapshot -\u003e\n                _currentSpace.value \u003d snapshot.data()\n            }\n        }\n        viewModelScope.launch {\n            // Listen for posts in this space\n            // CORRECTED: \u0027equalTo\u0027 is replaced with the \u0027isEqualTo\u0027 infix operator.\n            firestore.collection(\&quot;feeds\&quot;)\n                .where { \&quot;spaceId\&quot; isEqualTo spaceId }\n                .snapshots.collect { snapshot -\u003e\n                    _spacePosts.value \u003d snapshot.documents.map { it.data() }\n                }\n        }\n    }\n\n    /**\n     * Establishes a real-time listener for chat messages within a specific space.\n     */\n    fun listenForChatMessages(spaceId: String) {\n        viewModelScope.launch {\n            firestore.collection(\&quot;spaces\&quot;).document(spaceId).collection(\&quot;messages\&quot;)\n                .orderBy(\&quot;timestamp\&quot;)\n                .snapshots.collect { snapshot -\u003e\n                    _spaceMessages.value \u003d snapshot.documents.map { it.data() }\n                }\n        }\n    }\n\n    /**\n     * Sends a new chat message to the currently viewed space.\n     */\n    fun sendChatMessage(spaceId: String) {\n        val text \u003d newMessageText.value.trim()\n        if (text.isBlank()) return\n\n        val currentUser \u003d auth.currentUser ?: return\n        viewModelScope.launch {\n            // CORRECTED: document() with no arguments creates a new document with a unique ID.\n            val messageId \u003d firestore.collection(\&quot;spaces\&quot;).document().id\n            val message \u003d SpaceMessage(\n                id \u003d messageId,\n                spaceId \u003d spaceId,\n                authorId \u003d currentUser.uid,\n                authorName \u003d currentUser.displayName ?: \&quot;User\&quot;,\n                authorAvatarUrl \u003d currentUser.photoURL ?: \&quot;\&quot;,\n                text \u003d text\n            )\n            firestore.collection(\&quot;spaces\&quot;).document(spaceId)\n                .collection(\&quot;messages\&quot;).document(messageId).set(message)\n\n            newMessageText.value \u003d \&quot;\&quot; // Clear input field after sending\n        }\n    }\n\n    /**\n     * Clears all detailed space data to prevent data leaks and unnecessary listeners\n     * when the user navigates away from the SpaceDetailScreen.\n     */\n    fun clearSpaceDetails() {\n        _currentSpace.value \u003d null\n        _spacePosts.value \u003d emptyList()\n        _spaceMessages.value \u003d emptyList()\n    }\n}\n\n```\n\u003c/current_file\u003e\n\n\n\u003clinter_errors\u003e\n## Linter Errors\n\nPath: composeApp/src/commonMain/kotlin/viewmodels/SpaceViewModel.kt\nErrors:\n\nLine 497: No value passed for parameter \u0027documentPath\u0027.\nLine 559: Unresolved reference \u0027isEqualTo\u0027.\nLine 589: No value passed for parameter \u0027documentPath\u0027.\n\u003c/linter_errors\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nNo value passed for parameter \u0027documentPath\u0027\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[]}]}}" />
  </component>
</project>